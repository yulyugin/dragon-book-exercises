# 2.2 Syntax Definition

## Exercise 2.2.1
Consider the context-free grammar `S -> S S + | S S * | a`

a) Show how the string `aa+a*` can be generated by this grammar.

**Answer:**
1. `a` is `S` because `S -> a`,
2. `aa+` is `S` because `a` is `S` and `S -> S S +`,
3. `aa+a*` is `S` because `aa+` is `S`, `a` is `S` and `S -> S S *`.

b) Construct a parse tree for this string.

**Answer:**

![2.1.b](./img/2.2.1.b.svg)

c) What language is generated by this grammar? Justify your answer.

**Answer:** L = {postfix expression consisting of `a`s, `+` and `*` signs}.

## Exercise 2.2.2
What language is generated by the following grammars?
In each case justify your answer.

a) `S -> 0 S 1 | 0 1`

**Answer:** L = {0<sup>n</sup> 1<sup>n</sup>, where n >= 1}.

b) `S -> + S S | - S S | a`

**Answer:** L = {prefix notation consisting of `a`s, `+` and `-` signs}.

c) `S -> S ( S ) S | ϵ`

**Answer:** L = {matched brackets of arbitrary amount and nesting, includes empty string}.

d) `S -> a S b S | b S a S | ϵ`

**Answer:** L = {All strings of `a`s and `b`s that have the same amount of `a`s and
     `b`s, includes empty string}.

e) `S -> a | S + S | S S | S * | ( S )`

**Answer:** L = {Regular expression to describe
     [regular language](https://en.wikipedia.org/wiki/Regular_language)}.

## Exercise 2.2.3
Which of the grammars in Exercise 2.2 are ambiguous?

**Answer:**

a) No.

b) No.

c) Yes. For example: "()()".

![2.3.c](./img/2.2.3.c.svg)

d) Yes. For example: "abab".

![2.3.d](./img/2.2.3.d.svg)

e) Yes. For example: "aaa".

![2.3.e](./img/2.2.3.e.svg)

## Exercise 2.2.4
Construct unambiguous context-free grammars for each of the following
languages. In each case show that your grammar is correct.

a) Arithmetic expressions in postfix notation.

**Answer:** `expr -> num | expr expr - | expr expr + | expr expr * | expr expr /`

b) Left-associative lists of identifiers separated by commas.

**Answer:** `list -> list, id | id`

c) Right-associative lists of identifiers separated by commas.

**Answer:** `list -> id, list | id`

d) Arithmetic expressions of integers and identifiers with the four binary
operators +, -, *, /.

**Answer:**
```
expr -> expr + term | expr - term | term
term -> term * factor | term / factor | factor
factor -> num | id | ( expr )
```

e) Add unary plus and minus to the arithmetic operators of (d)

**Answer:**
```
expr -> expr + term | expr - term | term
term -> term * unary | term / unary | unary
unary -> - factor | + factor | factor
factor -> num | id | ( expr )
```

## Exercise 2.2.5
a) Show that all binary strings generated by the following grammar have values
divisible by 3. *Hint.* Use induction on the number of nodes in a parse tree.

`num -> 11 | 1001 | num  0 | num num`

**Proof:**

`11 = 3` is divisible by 3.

`1001 = 9` is divisible by 3.

`num 0` is equivalent to `num` multiplication by 2. Thus `num 0` is divisible
by 3 if `num` is divisible by 3.

`num num` is equivalent to `num_1 * 2 ^ length(num_2) + num_2`.
`num_1 * 2 ^ length(num_2)` is divisible by 3 if `num_1` is divisible by 3.
Thus `num_1 * 2 ^ length(num_2) + num_2` is divisible by 3 if both `num_1`
and `num_2` are divisible by 3.

Basic number generated by production rules `num -> 11 | 1001` are divisible
by 3 and thus all the numbers generated by production rules
`num -> num 0 | num num` will also be divisible by 3.

b) Does the grammar generate all binary strings with values divisible by 3?

**Answer:**
No. For example, `21 = 10101` is divisible by 3 but cannot be generated by
the grammar.

## Exercise 2.2.6
Construct a context-free grammar for roman numerals.

**Answer:**
```
ones -> I | II | III | ϵ
all_ones -> ones | IV | V ones | IX
tens -> X | XX | XXX | ϵ
all_tens -> tens | XL | L tens | XC
hundreds -> C | CC | CCC | ϵ
all_hundreds -> hundreds | CD | D hundreds | CM
thousands -> M | MM | MMM | ϵ

romans -> thousands all_hundreds all_tens all_ones
```
