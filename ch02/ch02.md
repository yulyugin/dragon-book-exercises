# Chapter 2, A Simple One-Pass Compiler

## 2.1
Consider the context-free grammar `S -> S S + | S S * | a`

a) Show how the string `aa+a*` can be generated by this grammar.
1. `a` is `S` because `S -> a`,
2. `aa+` is `S` because `a` is `S` and `S -> S S +`,
3. `aa+a*` is `S` because `aa+` is `S`, `a` is `S` and `S -> S S *`.

b) Construct a parse tree for this string.

![2.1.b](./img/2.1.b.png)

c) What language is generated by this grammar? Justify your answer.

L = {postfix expression consisting of `a`s, `+` and `*` signs}.

## 2.2
What language is generated by the following grammars?
In each case justify your answer.

a) `S -> 0 S 1 | 0 1`

L = {0<sup>n</sup> 1<sup>n</sup>, where n >= 1}.

b) `S -> + S S | - S S | a`

L = {prefix notation consisting of `a`s, `+` and `-` signs}.

c) `S -> S ( S ) S | ϵ`

L = {matched brackets of arbitrary amount and nesting, includes empty string}.

d) `S -> a S b S | b S a S | ϵ`

L = {All strings of `a`s and `b`s that have the same amount of `a`s and
     `b`s, includes empty string}.

e) `S -> a | S + S | S S | S * | ( S )`

L = {Regular expression to describe
     [regular language](https://en.wikipedia.org/wiki/Regular_language)}.

## 2.3
Which of the grammars in Exercise 2.2 are ambiguous?

a) No.

b) No.

c) Yes. For example: "()()".

![2.3.c](./img/2.3.c.png)

d) Yes. For example: "abab".

![2.3.d](./img/2.3.d.png)

e) Yes. For example: "aaa".

![2.3.e](./img/2.3.e.png)

## 2.4
Construct unambiguous context-free grammars for each of the following
languages. In each case show that your grammar is correct.

a) Arithmetic expressions in postfix notation.
`expr -> num | expr expr - | expr expr + | expr expr * | expr expr /`

b) Left-assosiative lists of identifiers separated by commas.

`list -> list, id | id`

c) Right-associative lists of identifiers separated by commas.

`list -> id, list | id`

d) Arithmetic expressions of integers and identifiers with the four binary
operators +, -, *, /.

```
expr -> expr + term | expr - term | term
term -> term * factor | term / factor | factor
factor -> num | id | ( expr )
```

e) Add unary plus and minus to the arithmetic operators of (d)

```
expr -> expr + term | expr - term | term
term -> term * unary | term / unary | unary
unary -> - factor | + factor | factor
factor -> num | id | ( expr )
```

## 2.5
a) Show that all binary strings generated by the following grammar have values
divisible by 3. *Hint.* Use induction on the number of nodes in a parse tree.

`num -> 11 | 1001 | num  0 | num num`

Proof:

`11 = 3` is divisible by 3.

`1001 = 9` is divisible by 3.

`num 0` is equivalent to `num` multiplication by 2. Thus `num 0` is divisible
by 3 if `num` is divisible by 3.

`num num` is equivalent to `num_1 * 2 ^ length(num_2) + num_2`.
`num_1 * 2 ^ length(num_2)` is divisible by 3 if `num_1` is divisible by 3.
Thus `num_1 * 2 ^ length(num_2) + num_2` is divisible by 3 if both `num_1`
and `num_2` are divisible by 3.

Basic number generated by producetion rules `num -> 11 | 1001` are divisible
by 3 and thus all the numbers generated by production rules
`num -> num 0 | num num` will also be divisible by 3.

b) Does the grammar generate all binary strings with values divisible by 3?

No. For example, `21 = 10101` is divisible by 3 but cannot be generated by
the grammar.

## 2.6
Construct a conext-free grammar for roman numerals.

```
ones -> I | II | III | ϵ
all_ones -> ones | IV | V ones | IX
tens -> X | XX | XXX | ϵ
all_tens -> tens | XL | L tens | XC
hundreds -> C | CC | CCC | ϵ
all_hundreds -> hundreds | CD | D hundreds | CM
thousands -> M | MM | MMM | ϵ

romans -> thousands all_hundreds all_tens all_ones
```

## 2.7
Construct a syntax-directed translation scheme that translates
arithmetic expressions from infix notation into prefix notation in which an
operator appears before its operands; e.g., `-xy` is the prefix notation for
`x-y`. Give annotated parse trees for the inputs `9-5+2` and `9-5*2`.

```
expr -> {print('+')} expr + term
expr -> {print('-')} expr - term
expr -> term
term -> {print('*')} term * factor
term -> {print('/')} term / factor
term -> factor
factor -> {print('0')} 0
factor -> {print('1')} 1
...
factor -> {print('9')} 9
factor -> ( expr )
```

Annotated parse tree for `9-5+2`

![2.7](./img/2.7.png)

Annotated parse tree for `9-5*2`

![2.7-mul](./img/2.7-mul.png)

## 2.8
Construct a syntax-directed translation scheme that translates
arithmetic expressions from postfix notation into infix notation. Give
annotated parse trees for the inputs `95-2*` and `952*-`.

```
expr -> expr {print('*')} expr *
expr -> expr {print{'/')} expr /
expr -> {print('(')} expr {print('+')} expr {print(')')} +
expr -> {print('(')} expr {print('-')} expr {print(')')} -
expr -> 0 {print('0')}
expr -> 1 {print('1')}
...
expr -> 9 {print('9')}
```

Annotated parse tree for `95-2*`

![2.8](./img/2.8.png)

Annotated parse tree for `952*-`

![2.8-2](./img/2.8-2.png)

## 2.9
Construct a syntax-directed translation scheme that translates integers into
roman numerals.

```
ones -> 0
ones -> 1 {print('I')}
ones -> 2 {print('II')}
ones -> 3 {print('III')}
ones -> 4 {print('IV')}
ones -> 5 {print('V')}
ones -> 6 {print('VI')}
ones -> 7 {print('VII')}
ones -> 8 {print('VIII')}
ones -> 9 {print('IX')}
tens -> 0
tens -> 1 {print('X')}
tens -> 2 {print('XX')}
tens -> 3 {print('XXX')}
tens -> 4 {print('XL')}
tens -> 5 {print('L')}
tens -> 6 {print('LX')}
tens -> 7 {print('LXX')}
tens -> 8 {print('LXXX')}
tens -> 9 {print('XC')}
hundreds -> 0
hundreds -> 1 {print('C')}
hundreds -> 2 {print('CC')}
hundreds -> 3 {print('CCC')}
hundreds -> 4 {print('CD')}
hundreds -> 5 {print('D')}
hundreds -> 6 {print('DC')}
hundreds -> 7 {print('DCC')}
hundreds -> 8 {print('DCCC')}
hundreds -> 9 {print('CM')}
thousands -> ϵ
thousands -> 1 {print('M')}
thousands -> 2 {print('MM')}
thousands -> 3 {print('MMM')}
int -> thousands hundreds tens ones | tens ones | ones
```

## 2.10
Construct a syntax-directed translation scheme that translated roman
numerals into integers.

```
ones -> ϵ
ones -> I {tmp += 1}
ones -> II {tmp += 2}
ones -> III {tmp += 3}
all_ones -> ones
all_ones -> IV {tmp += 4}
all_ones -> V ones {tmp += 5}
all_ones -> IX {tmp += 9}
tens -> ϵ
tens -> X {tmp += 10}
tens -> XX {tmp += 20}
tens -> XXX {tmp += 30}
all_tens -> tens
all_tens -> XL {tmp += 40}
all_tens -> L tens {tmp += 50}
all_tens -> XC {tmp += 90}
hundreds -> ϵ
hundreds -> C {tmp += 100}
hundreds -> CC {tmp += 200}
hundreds -> CCC {tmp += 300}
all_hundreds -> hundreds
all_hundreds -> CD {tmp += 400}
all_hundreds -> D hundreds {tmp += 500}
all_hundreds -> MC {tmp += 900}
thousands -> ϵ
thousands -> M {tmp += 1000}
thousands -> MM {tmp += 2000}
thousands -> MMM {tmp += 3000}
romans -> thousands all_hundreds all_tens all_ones {print(tmp)}
```
